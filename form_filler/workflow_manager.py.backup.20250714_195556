"""
表單自動填寫工作流管理器
集成所有組件，實現完整的自動化流程
"""
import os
import logging
import asyncio
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
from urllib.parse import urlparse
from playwright.async_api import async_playwright, Page, Browser, BrowserContext
import json

from .services.field_parser import FieldParser
from .services.page_analyzer import PageAnalyzer
from .services.gpt_service import GPTService
from .services.smart_form_filler import SmartFormFiller
from .services.field_validator import FieldValidator
from .models.page_types import PageType, ActionType, PageAnalysisResult
from .models.form_fields import FormField
from .utils.dom_extractor import DOMExtractor
from .utils.error_reporter import ErrorReporter
from ingestion.services.notion_service import NotionService

logger = logging.getLogger(__name__)


class WorkflowManager:
    """工作流管理器，協調所有組件完成表單填寫任務"""
    
    def __init__(self, config: Dict[str, Any]):
        """
        初始化工作流管理器
        
        Args:
            config: 配置字典，包含各種API密鑰和設置
        """
        self.config = config
        
        # 初始化服務
        # GPTService reads API key from environment variable
        if config.get('openai_api_key'):
            os.environ['OPENAI_API_KEY'] = config['openai_api_key']
        self.gpt_service = GPTService()
        self.page_analyzer = PageAnalyzer(self.gpt_service)
        self.field_parser = FieldParser()
        self.smart_filler = SmartFormFiller(self.gpt_service)
        self.field_validator = None  # Will be initialized per page instance
        self.dom_extractor = None  # Will be initialized per page instance
        self.error_reporter = ErrorReporter(
            errors_file=os.path.join(config.get('log_dir', 'logs'), 'errors.jsonl'),
            screenshots_dir=os.path.join(config.get('screenshot_dir', 'screenshots'), 'errors')
        )
        
        # 初始化Notion服務（如果配置了）
        self.notion_service = None
        if config.get('notion_token') and config.get('database_id'):
            self.notion_service = NotionService(
                token=config['notion_token'],
                database_id=config['database_id']
            )
        
        # 設置日誌和截圖目錄
        self.log_dir = Path(config.get('log_dir', 'logs'))
        self.screenshot_dir = Path(config.get('screenshot_dir', 'screenshots'))
        self.log_dir.mkdir(exist_ok=True)
        self.screenshot_dir.mkdir(exist_ok=True)
        
        # 工作流狀態
        self.current_session_id = None
        self.session_logs = []
        self.domain_changes = []
        self.playwright = None
        
    async def process_job_application(self, url: str, job_id: str = None, 
                                    submit: bool = False, headless: bool = False) -> Dict[str, Any]:
        """
        處理單個職位申請的完整工作流
        
        Args:
            url: 職位申請頁面URL
            job_id: 職位ID（用於Notion更新）
            submit: 是否自動提交表單
            headless: 是否使用無頭瀏覽器
            
        Returns:
            處理結果字典
        """
        # 創建會話ID
        self.current_session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._log_step("開始處理職位申請", {"url": url, "job_id": job_id})
        
        browser = None
        context = None
        page = None
        result = {
            'success': False,
            'session_id': self.current_session_id,
            'url': url,
            'job_id': job_id,
            'steps': [],
            'error': None,
            'screenshots': [],
            'filled_fields': {},
            'submitted': False
        }
        
        try:
            # 步驟1: 啟動瀏覽器
            self._log_step("啟動瀏覽器", {"headless": headless})
            browser, context, page = await self._launch_browser(headless)
            
            # Initialize DOM Extractor per page instance
            self.dom_extractor = DOMExtractor(page)

            # 設置頁面事件監聽
            await self._setup_page_listeners(page)
            
            # 步驟2: 導航到目標頁面
            self._log_step("導航到目標頁面", {"url": url})
            await page.goto(url, wait_until='networkidle', timeout=30000)
            await asyncio.sleep(2)  # 等待頁面完全加載
            
            # 保存初始截圖
            initial_screenshot = await self._take_screenshot(page, "initial")
            result['screenshots'].append(initial_screenshot)
            
            # 步驟3: 分析頁面並執行相應動作
            max_attempts = 5
            attempt = 0
            
            while attempt < max_attempts:
                attempt += 1
                self._log_step(f"分析頁面 (第{attempt}次)", {})
                
                # 提取頁面信息
                page_info = await self._extract_page_info(page)
                
                # 分析頁面類型
                analysis_result = self.page_analyzer.analyze_page(
                    url=page.url,
                    title=page_info['title'],
                    content=page_info['content'],
                    buttons=page_info['buttons'],
                    forms=page_info['forms']
                )
                
                # 獲取推薦動作
                recommended_action = self.page_analyzer.get_recommended_action(
                    url=page.url,
                    title=page_info['title'],
                    content=page_info['content'],
                    buttons=page_info['buttons'],
                    forms=page_info['forms']
                )
                
                self._log_step("頁面分析結果", {
                    "page_type": analysis_result.page_type.value,
                    "confidence": analysis_result.confidence,
                    "recommended_action": recommended_action.action_type.value,
                    "action_confidence": recommended_action.confidence
                })
                
                # 根據推薦動作執行
                if recommended_action.action_type == ActionType.FILL_FORM:
                    # 填寫表單
                    self._log_step("開始填寫表單", {})
                    fill_result = await self._fill_form(page, analysis_result)
                    result['filled_fields'] = fill_result['filled_fields']
                    result['steps'].append({
                        'action': 'fill_form',
                        'success': fill_result['success'],
                        'details': fill_result
                    })
                    
                    # 驗證填寫結果
                    if fill_result['success']:
                        validation_result = await self._validate_form(page, fill_result.get('filled_fields'))
                        if validation_result['valid']:
                            self._log_step("表單驗證通過", validation_result)
                            
                            # 如果設置了自動提交
                            if submit:
                                submit_result = await self._submit_form(page)
                                result['submitted'] = submit_result['success']
                                result['steps'].append({
                                    'action': 'submit_form',
                                    'success': submit_result['success'],
                                    'details': submit_result
                                })
                            
                            result['success'] = True
                            break
                        else:
                            self._log_step("表單驗證失敗", validation_result)
                    
                elif recommended_action.action_type == ActionType.CLICK_CTA:
                    # 點擊CTA按鈕
                    if analysis_result.cta_candidates:
                        cta = analysis_result.cta_candidates[0]
                        self._log_step(f"點擊CTA按鈕: {cta.text}", {"selector": cta.selector})
                        
                        click_result = await self._click_cta(page, cta)
                        result['steps'].append({
                            'action': 'click_cta',
                            'target': cta.text,
                            'success': click_result['success'],
                            'details': click_result
                        })
                        
                        if click_result['success']:
                            # 等待頁面變化
                            await asyncio.sleep(3)
                            
                            # 檢查是否發生了域名變化
                            new_domain = urlparse(page.url).netloc
                            old_domain = urlparse(url).netloc
                            if new_domain != old_domain:
                                self._log_step("檢測到域名變化", {
                                    "old_domain": old_domain,
                                    "new_domain": new_domain
                                })
                                self.domain_changes.append({
                                    'from': old_domain,
                                    'to': new_domain,
                                    'timestamp': datetime.now().isoformat()
                                })
                        else:
                            # CTA點擊失敗，可能需要人工干預
                            break
                    else:
                        self._log_step("沒有找到合適的CTA按鈕", {})
                        break
                
                elif recommended_action.action_type == ActionType.LOGIN_REQUIRED:
                    self._log_step("需要登錄", {})
                    await self.error_reporter.report_login_required(url, self.current_session_id)
                    result['error'] = "需要登錄才能繼續"
                    break
                
                elif recommended_action.action_type == ActionType.WAIT_FOR_HUMAN:
                    self._log_step("需要人工干預", {"reason": recommended_action.reasoning})
                    await self.error_reporter.report_human_intervention_needed(
                        url, recommended_action.reasoning, self.current_session_id
                    )
                    result['error'] = f"需要人工干預: {recommended_action.reasoning}"
                    break
                
                else:
                    self._log_step("無需執行動作或動作類型未知", {})
                    break
                
                # 保存步驟截圖
                step_screenshot = await self._take_screenshot(page, f"step_{attempt}")
                result['screenshots'].append(step_screenshot)
            
            # 保存最終截圖
            final_screenshot = await self._take_screenshot(page, "final")
            result['screenshots'].append(final_screenshot)
            
        except Exception as e:
            logger.error(f"工作流執行失敗: {str(e)}", exc_info=True)
            result['error'] = str(e)
            await self.error_reporter.report_error(url, e, self.current_session_id)
            
        finally:
            # 清理資源
            if page:
                await page.close()
            if context:
                await context.close()
            if browser:
                await browser.close()
            if hasattr(self, 'playwright') and self.playwright:
                await self.playwright.stop()
            
            # 保存會話日誌
            await self._save_session_logs()
            
            # 更新Notion狀態
            if self.notion_service and job_id:
                await self._update_notion_status(job_id, result)
        
        return result
    
    async def _launch_browser(self, headless: bool = False) -> Tuple[Browser, BrowserContext, Page]:
        """啟動瀏覽器並創建頁面"""
        self.playwright = await async_playwright().start()
        
        # 瀏覽器啟動選項
        launch_options = {
            'headless': headless,
            'args': [
                '--disable-blink-features=AutomationControlled',
                '--disable-features=site-per-process',
            ]
        }
        
        # 使用Chrome/Chromium
        browser = await self.playwright.chromium.launch(**launch_options)
        
        # 創建瀏覽器上下文
        context = await browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            user_agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            locale='zh-CN',
            timezone_id='Asia/Shanghai'
        )
        
        # 創建頁面
        page = await context.new_page()
        
        return browser, context, page
    
    async def _setup_page_listeners(self, page: Page):
        """設置頁面事件監聽器"""
        # 監聽控制台輸出
        page.on('console', lambda msg: logger.debug(f"Browser console: {msg.text}"))
        
        # 監聽頁面錯誤
        page.on('pageerror', lambda err: logger.error(f"Page error: {err}"))
        
        # 監聽對話框
        async def handle_dialog(dialog):
            logger.info(f"Dialog appeared: {dialog.message}")
            await dialog.accept()
        
        page.on('dialog', handle_dialog)
    
    async def _extract_page_info(self, page: Page) -> Dict[str, Any]:
        """提取頁面信息"""
        # 獲取頁面標題
        title = await page.title()
        
        # 提取頁面內容
        content = await self.dom_extractor.extract_page_content()
        
        # 提取按鈕信息
        buttons = await self.dom_extractor.extract_buttons()
        
        # 提取表單信息
        forms = await self.field_parser.extract_all_forms(page)
        
        return {
            'title': title,
            'content': content,
            'buttons': buttons,
            'forms': forms
        }
    
    async def _fill_form(self, page: Page, analysis_result: PageAnalysisResult) -> Dict[str, Any]:
        """填寫表單"""
        result = {
            'success': False,
            'filled_fields': {},
            'errors': []
        }
        
        try:
            # 提取表單字段
            fields = await self.field_parser.extract_fields(page)
            
            if not fields:
                result['errors'].append("未找到表單字段")
                return result
            
            # 填寫表單
            fill_result = await self.smart_filler.fill_form(page, fields)
            
            result['success'] = fill_result.get('success', False)
            result['filled_fields'] = fill_result.get('filled_fields', {})
            result['errors'] = fill_result.get('errors', [])
            
        except Exception as e:
            logger.error(f"填寫表單失敗: {str(e)}", exc_info=True)
            result['errors'].append(str(e))
        
        return result
    
    async def _validate_form(self, page: Page, filled_fields: Dict[str, Any] = None) -> Dict[str, Any]:
        """驗證表單填寫結果"""
        try:
            # For now, skip validation if no filled fields provided
            if not filled_fields:
                return {
                    'valid': True,
                    'errors': [],
                    'message': 'Validation skipped - no filled fields data'
                }
            
            # Initialize FieldValidator if not already done
            if self.field_validator is None:
                self.field_validator = FieldValidator(page)
            
            # Transform filled_fields dict to list format expected by validator
            fields_list = []
            for selector, field_data in filled_fields.items():
                fields_list.append({
                    'selector': selector,
                    'value': field_data.get('value', ''),
                    'field_info': field_data
                })
            
            validation_result = await self.field_validator.validate_all_fields(fields_list)
            return {
                'valid': validation_result.get('validation_rate', 0) >= 0.8,  # 80% threshold
                'errors': [f['selector'] for f in validation_result.get('failed_field_details', [])],
                'details': validation_result
            }
        except Exception as e:
            logger.error(f"驗證表單失敗: {str(e)}", exc_info=True)
            return {
                'valid': False,
                'errors': [str(e)]
            }
    
    async def _submit_form(self, page: Page) -> Dict[str, Any]:
        """提交表單"""
        result = {
            'success': False,
            'message': ''
        }
        
        try:
            # 查找提交按鈕
            submit_selectors = [
                'button[type="submit"]',
                'input[type="submit"]',
                'button:has-text("Submit")',
                'button:has-text("提交")',
                'button:has-text("Apply")',
                'button:has-text("申請")'
            ]
            
            submit_button = None
            for selector in submit_selectors:
                try:
                    submit_button = await page.wait_for_selector(selector, timeout=3000)
                    if submit_button:
                        break
                except:
                    continue
            
            if submit_button:
                # 點擊提交按鈕
                await submit_button.click()
                await asyncio.sleep(5)  # 等待提交完成
                
                # 檢查是否有成功消息
                success_indicators = [
                    'text="Thank you"',
                    'text="Success"',
                    'text="submitted"',
                    'text="謝謝"',
                    'text="成功"',
                    'text="已提交"'
                ]
                
                for indicator in success_indicators:
                    try:
                        success_element = await page.wait_for_selector(indicator, timeout=3000)
                        if success_element:
                            result['success'] = True
                            result['message'] = "表單提交成功"
                            break
                    except:
                        continue
            else:
                result['message'] = "未找到提交按鈕"
            
        except Exception as e:
            logger.error(f"提交表單失敗: {str(e)}", exc_info=True)
            result['message'] = str(e)
        
        return result
    
    async def _click_cta(self, page: Page, cta) -> Dict[str, Any]:
        """點擊CTA按鈕"""
        result = {
            'success': False,
            'navigation_occurred': False,
            'new_url': None,
            'error': None
        }
        
        try:
            # 記錄當前URL
            old_url = page.url
            
            # 嘗試點擊CTA
            element = await page.wait_for_selector(cta.selector, timeout=5000)
            if element:
                await element.click()
                
                # 等待可能的導航
                try:
                    await page.wait_for_load_state('networkidle', timeout=10000)
                except:
                    pass
                
                # 檢查是否發生了導航
                new_url = page.url
                if new_url != old_url:
                    result['navigation_occurred'] = True
                    result['new_url'] = new_url
                
                result['success'] = True
            else:
                result['error'] = "未找到CTA元素"
                
        except Exception as e:
            logger.error(f"點擊CTA失敗: {str(e)}", exc_info=True)
            result['error'] = str(e)
        
        return result
    
    async def _take_screenshot(self, page: Page, name: str) -> str:
        """截圖並保存"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.current_session_id}_{name}_{timestamp}.png"
        filepath = self.screenshot_dir / filename
        
        await page.screenshot(path=str(filepath), full_page=True)
        self._log_step(f"保存截圖: {filename}", {})
        
        return str(filepath)
    
    def _log_step(self, step: str, details: Dict[str, Any]):
        """記錄工作流步驟"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'session_id': self.current_session_id,
            'step': step,
            'details': details
        }
        
        self.session_logs.append(log_entry)
        logger.info(f"[{self.current_session_id}] {step}: {json.dumps(details, ensure_ascii=False)}")
    
    async def _save_session_logs(self):
        """保存會話日誌"""
        if not self.session_logs:
            return
        
        log_file = self.log_dir / f"session_{self.current_session_id}.json"
        
        session_data = {
            'session_id': self.current_session_id,
            'start_time': self.session_logs[0]['timestamp'],
            'end_time': self.session_logs[-1]['timestamp'],
            'domain_changes': self.domain_changes,
            'logs': self.session_logs
        }
        
        with open(log_file, 'w', encoding='utf-8') as f:
            json.dump(session_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"會話日誌已保存: {log_file}")
    
    async def _update_notion_status(self, job_id: str, result: Dict[str, Any]):
        """更新Notion數據庫中的任務狀態"""
        if not self.notion_service:
            return
        
        try:
            # 根據結果確定狀態
            if result['success']:
                if result['submitted']:
                    status = "Submitted"
                else:
                    status = "Filled"
            else:
                if result['error']:
                    if "登錄" in result['error']:
                        status = "Login_Required"
                    else:
                        status = "Failed"
                else:
                    status = "Error"
            
            # 更新Notion記錄
            update_data = {
                'Status': status,
                'Last_Error': result.get('error', ''),
                'Session_ID': self.current_session_id,
                'Screenshots': ', '.join(result['screenshots']),
                'Processed_Time': datetime.now().isoformat()
            }
            
            # 這裡需要實現actual的Notion更新邏輯
            # await self.notion_service.update_job(job_id, update_data)
            
            logger.info(f"Notion狀態已更新: {job_id} -> {status}")
            
        except Exception as e:
            logger.error(f"更新Notion狀態失敗: {str(e)}", exc_info=True)
